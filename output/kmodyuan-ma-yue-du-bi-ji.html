<!DOCTYPE html>
<html lang="zh">
<head>

        <title>kmod源码阅读笔记</title>
        <meta charset="utf-8" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="/theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="/theme/style.css" />
        <link rel="stylesheet" type="text/css" href="/theme/pygment.css" />

        <script src="/theme/js/libs/modernizr-2.6.2.min.js"></script>






</head>

<body id="index" class="home">


    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1><a href="">荒野丛林 <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>
             
              <ul class="columns">
                <li><a href="">Home</a></li>


              </ul>
            </div>

<section id="content" class="body">

   <div class="row">
        <div class="eleven columns">


            <header>
              <h2 class="entry-title">
                <a href="/kmodyuan-ma-yue-du-bi-ji.html" rel="bookmark"
                   title="Permalink to kmod源码阅读笔记">kmod源码阅读笔记</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="2013-12-14T00:00:00">
                六 14 十二月 2013
              </abbr>
              <address class="vcard author">
                By <a class="url fn" href="/author/walter.html">Walter</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <p>kmod<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>是处理Linux内核模块的一系列工具集,可以插入，删除，显示，检查属性，解决模块依赖和创建别名。
取代了module-init-tools。</p>
<p>首先看main函数:</p>
<div class="highlight"><pre><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">err</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">program_invocation_short_name</span><span class="p">,</span> <span class="s">&quot;kmod&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">handle_kmod_commands</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">handle_kmod_compat_commands</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>program_invocation_short_name是GNU扩展,表示执行程序时，程序的名称(不包含路径信息)。还有一个
program_invocation_name表示程序的全部名称（包含路径信息），等价于argv[0]。program_invocation_name
使用起来比较方便，不需要硬生生的使用argv[0]。通过man
program_invocation_name可以查看相关信息。</p>
<div class="highlight"><pre>SYNOPSIS
       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include &lt;errno.h&gt;

       extern char *program_invocation_name;
       extern char *program_invocation_short_name;
</pre></div>


<p>program_invocation_short_name声明在errno.h里:</p>
<div class="highlight"><pre><span class="cp">#ifdef __USE_GNU</span>

<span class="cm">/* The full and simple forms of the name with which the program was</span>
<span class="cm">   invoked.  These variables are set up automatically at startup based on</span>
<span class="cm">   the value of ARGV[0] (this works only if you use GNU ld).  */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">program_invocation_name</span><span class="p">,</span> <span class="o">*</span><span class="n">program_invocation_short_name</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* __USE_GNU */</span><span class="cp"></span>
</pre></div>


<p>为啥源码里判断的是__USE_GNU宏，而man手册里的是_GNU_SOURCE？在features.h里：</p>
<div class="highlight"><pre><span class="cp">#ifdef  _GNU_SOURCE</span>
<span class="cp"># define __USE_GNU  1</span>
<span class="cp">#endif</span>
</pre></div>


<p>这个扩展,在使用GCC编译时，通过-D_GNU_SOURCE定义宏_GNU_SOURCE。GCC不会默认定义这个宏，
查看GCC默认定义的宏，可以使用命令行：</p>
<div class="highlight"><pre>% gcc -dM -E - &lt;/dev/null  <span class="c">#-dM可以理解为dump Macro</span>
</pre></div>


<p>程序首先比较用户是否以kmod指令触发。如果是，则调用handle_kmod_commands函数处理，可以看出kmod支持自身的命令触发，
在命令行下，查看kmod基本的帮助信息:</p>
<div class="highlight"><pre>localhost wolf <span class="c"># kmod</span>
missing <span class="nb">command</span>
kmod - Manage kernel modules: list, load, unload, etc
Usage:
    kmod <span class="o">[</span>options<span class="o">]</span> <span class="nb">command</span> <span class="o">[</span>command_options<span class="o">]</span>

Options:
    -V, --version     show version
    -h, --help        show this <span class="nb">help</span>

Commands:
  <span class="nb">help         </span>Show <span class="nb">help </span>message
  list         list currently loaded modules
  static-nodes outputs the static-node information installed with the currently running kernel

kmod also handles gracefully <span class="k">if </span>called from following symlinks:
  lsmod        compat lsmod <span class="nb">command</span>
<span class="nb">  </span>rmmod        compat rmmod <span class="nb">command</span>
<span class="nb">  </span>insmod       compat insmod <span class="nb">command</span>
<span class="nb">  </span>modinfo      compat modinfo <span class="nb">command</span>
<span class="nb">  </span>modprobe     compat modprobe <span class="nb">command</span>
<span class="nb">  </span>depmod       compat depmod <span class="nb">command</span>
</pre></div>


<p>可以看出kmod本身支持三个命令，其中一个是list,列举系统当前加载的模块。如果不是以kmod执行，则调用handle_kmod_compat_commands处理。
在编译可执行文件时，创建了几个链接到kmod,运行这几个链接时，program_invocation_short_name就是链接名，这样就调用到不同的命令。和busybox
的处理原理一样。</p>
<div class="highlight"><pre>localhost wolf <span class="c"># ls -l `which lsmod rmmod insmod modinfo modprobe depmod`</span>
lrwxrwxrwx 1 root root 10 10月 18 22:50 /sbin/depmod -&gt; /sbin/kmod
lrwxrwxrwx 1 root root 10 10月 18 22:50 /sbin/insmod -&gt; /sbin/kmod
lrwxrwxrwx 1 root root 10 10月 18 22:50 /sbin/lsmod -&gt; /sbin/kmod
lrwxrwxrwx 1 root root 10 10月 18 22:50 /sbin/modinfo -&gt; /sbin/kmod
lrwxrwxrwx 1 root root 10 10月 18 22:50 /sbin/modprobe -&gt; /sbin/kmod
lrwxrwxrwx 1 root root 10 10月 18 22:50 /sbin/rmmod -&gt; /sbin/kmod
</pre></div>


<p>handle_kmod_commands扫描命令行参数，getopt_long时GNU扩展(man 3 getopt可以查看详细的用法)。这里面的for(;;)语句完全是多余的，每一个条件
分支要么跳出，要么是return。完全可以使用如下语句替代:</p>
<div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="err">！</span><span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;h&#39;</span>:
        <span class="n">kmod_help</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;V&#39;</span>:
        <span class="n">puts</span><span class="p">(</span><span class="s">&quot;kmod version &quot;</span> <span class="n">VERSION</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;?&#39;</span>:
        <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
    <span class="nl">default:</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error: unexpected getopt_long() value &#39;%c&#39;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>接着遍历kmod_cmds，和传进来的参数进行比较，如果匹配上就调用相应的处理函数。先来看看ARRAY_SIZE定义，为了方便看，使用gdb的宏扩展功能。</p>
<div class="highlight"><pre><span class="o">(</span>gdb<span class="o">)</span> macro expand ARRAY_SIZE<span class="o">(</span>kmod_cmds<span class="o">)</span>
expands to: <span class="o">(</span>sizeof<span class="o">(</span>kmod_cmds<span class="o">)</span> / sizeof<span class="o">((</span>kmod_cmds<span class="o">)[</span>0<span class="o">])</span> + <span class="o">({</span> _Static_assert<span class="o">((</span>!__builtin_types_compatible_p<span class="o">(</span>typeof<span class="o">(</span>kmod_cmds<span class="o">)</span>, typeof<span class="o">(</span>&amp;<span class="o">(</span>kmod_cmds<span class="o">)[</span>0<span class="o">])))</span>, <span class="s2">&quot;!__builtin_types_compatible_p(typeof(kmod_cmds), typeof(&amp;(kmod_cmds)[0]))&quot;</span><span class="o">)</span>; 0; <span class="o">}))</span>


/* Two gcc extensions.
* &amp;a<span class="o">[</span>0<span class="o">]</span> degrades to a pointer: a different <span class="nb">type </span>from an array */
<span class="c">#define _array_size_chk(arr) ({ \</span>
assert_cc<span class="o">(</span>!__builtin_types_compatible_p<span class="o">(</span>typeof<span class="o">(</span>arr<span class="o">)</span>, typeof<span class="o">(</span>&amp;<span class="o">(</span>arr<span class="o">)[</span>0<span class="o">])))</span>; <span class="se">\</span>
0; <span class="se">\</span>
<span class="o">})</span>

define ARRAY_SIZE<span class="o">(</span>arr<span class="o">)</span> <span class="o">(</span>sizeof<span class="o">(</span>arr<span class="o">)</span> / sizeof<span class="o">((</span>arr<span class="o">)[</span>0<span class="o">])</span> + _array_size_chk<span class="o">(</span>arr<span class="o">))</span>
</pre></div>


<p>通常定义ARRAY_SIZE来表示数组的大小，<em> #define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x))) （arch/x86/boot/boot.h, line 36）</em>。
但是这里的定义后面还加了个尾_array_size_chk(arr)，意思很明确，对arr进行检查。在我的系统上(Funtoo X86_64 GCC4.8),宏最终被扩展成如上
的代码，无论如何扩展，宏最终的值都时0,所以不会对数组大小有影响。__builtin_types_compatible_p是gcc内置函数<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>,用于检查两个参数的类型是否一致，
相同，值为1,不同为0。typeof返回参数类型。_Static_assert是GCC扩展，顾名思义就是静态断言，用于编译时断言，对应于C11 static_assert。这段代码的意思
就是如果数组类型如果和指向数组第一个元素的指针类型不一致，则编译通过，否则编译通不过。啥时候编译通过不了？如果传进去一个指针，而不是数组，则编译不通过。
GCC内置函数的确很强大，一般来说数组作为参数传递，会退化为指针，而内置函数不会。看一下在不支持静态编译的系统上(编译器),如何实现类似的功能：</p>
<div class="highlight"><pre><span class="cp">#if defined(HAVE_STATIC_ASSERT)</span>
<span class="cp">#define assert_cc(expr) \</span>
<span class="cp">    _Static_assert((expr), #expr)</span>
<span class="cp">#else</span>
<span class="cp">#define assert_cc(expr) \</span>
<span class="cp">       do { (void) sizeof(char [1 - 2*!(expr)]); } while(0)</span>
<span class="cp">#endif</span>
</pre></div>


<p>#else分支的，使用sizeof(char [1-2*!(expr)])。如果expr值为1,对应于上面的两个类型不等（传进来的assert_cc的参数带一个!），sizeof(char [1])可以顺利
编译，如果expr为0,则sizeof(char [-1])，无法通过编译。顺便提一下，sizeof已经不完全是编译时确定，在C99标准<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>6.5..3.4-7，明确提到了运行时
（execution time)sizeof。本例中，不涉及变长参数数组。</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="https://www.kernel.org/pub/linux/utils/kernel/kmod/">https://www.kernel.org/pub/linux/utils/kernel/kmod/</a>&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p><a href="http://gcc.gnu.org/onlinedocs/gcc-3.3.6/gcc/Other-Builtins.html">http://gcc.gnu.org/onlinedocs/gcc-3.3.6/gcc/Other-Builtins.html</a>&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p><a href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf">http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf</a>&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>
            </div><!-- /.entry-content -->


        </div><!-- /.eleven.columns -->
        
<div class="three columns">

<h4>Pages</h4>

 <ul>
  </ul>

<h4>Categories</h4>
<ul>
		<li><a href="/category/2013-12.html">2013-12</a></li>
		<li><a href="/category/misc.html">misc</a></li>
</ul>


<h4>Tags</h4>



</div> </div><!-- /.row -->


</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">

    
        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">





              </ul>
            </div>
          </div>
        </footer>

    </div>


  <script src="/theme/js/libs/jquery-1.9.1.min.js"></script>
  <script src="/theme/js/libs/gumby.min.js"></script>
  <script src="/theme/js/plugins.js"></script>

</body>
</html>